下载和安装可以通过执行`npm i typescript -g`。js本身是一种弱类型的语言，而且它比较灵活，不过这就会在项目比较大之后不利于我们后期的代码维护之类的
## 语法基础
#### 类型推断
ts会根据给变量存放的初始值来进行变量类型限定，也就是说刚开始给的值是字符串，这个变量以后就只能存字符串。但是我们更推荐类型注解
#### 类型注解
我们可以通过给变量追加冒号数据类型来解释这个变量`let str: string = '123'`，这样我们也可以做预声明，只给声明不给数据，它还是个string
#### 类型断言
有时候我们可以断定一些数据一定会是某种数据类型，比如计算数据的和、最大值等，或者某些处理函数的返回值，这种情况我们可以`const result = ... as number`来让程序明白它一定会是个number。因为一般来说，如果这个值是个undefined或者一些其他的非正常数据，对其进行操作可能就会出错。所以我们使用这种方式要谨慎一些
#### 基础类型和联合类型
有时候我们的变量可能最终会被分为字符串，或者分配为null，那么这种情况我们就可以把多种类型联合起来一块注解上`let num: string | null = null`。我们也可以对变量可能出现的数据进行限定，比如`let num: 1 | 2 | 3 = ...`这样我们呢如果给num赋值5就会报错
#### 数组、元组、枚举
js里面数组可以存不同类型的数据，但是实际开发的时候我们是不建议用这种方式的。所以我们也可以通过类型注解等来约束数组可能存入的数据`let arr: number[] = [1, 3, 5]`或者`let str: Array<string> = ['a', 'ab']`等
元组类似于数组，但是它可以限定存储数据的个数以及每个数据的类型`let arr: [number, string, number] = [1, 'ab', 2]`，如果我们有某个位置的数据可能存在也可能不存在，我们可以在类型后面加问号来标记它，当然，所有的可选参数都应该在尾部，也可以给默认值。
枚举enum，枚举类型的变量我们要用大驼峰声明`enum MyEnum {A, B, C}`，我们可以通过直接访问元素或者用下标值来访问（下标按顺序从0开始计数），`MyEnum.A, MyEnum[0]`
还有一个void类型，严格模式下void只能被分配为undefined，我们很少直接用这种变量，一般都是一个函数没有返回值的时候就用void
#### 函数
函数的参数和返回值也可以进行类型限定`function myFn(a: number, b: string, c?: boolean, ...rest: number[]): void{}`
#### 接口
接口一般用于对象的定义
```typescript
interface Obj {
  name: string,
  age: number
}

const obj: Obj = {
  name: 'a',
  age: 18
}
```
#### type
有时候我们可能有很多数据都有可能传入不同类型的参数，这时候我们用类型注解等去一个一个给注解是很麻烦的，所以我们可以自定义类型`type MyUserName = string | number`然后只需要给变量注解注这个`MyUserName`就行了
#### 泛型
我们写函数的时候可能这个函数的参数会传入各种各样的值，我们也有可能想把这个函数变成比较通用的函数，这时候就可以用到泛型。但是，我们可能想到我们可以给参数注解多种数据类型，这种情况会出现交叉使用的情况，所以还是写泛型的好
```typescript
function myFn<T>(a: T, b: T): T[] {
  return [a, b]
}
myFn<number>(1, 2)
//当然，ts支持类型推断，所以这个<number>其实还是可以不写的，不过如果确定还是写的好
```
