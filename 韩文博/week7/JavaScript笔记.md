## 知识点
简单数据类型要发生变化的不能用const，复杂数据类型要发生变化的可以用const，因为复杂数据类型存的是地址，地址是不变的
## DOM
#### 获取DOM元素
获取匹配的第一个元素：document.querySelector('元素')，参数是包含一个或多个有效的CSS选择器字符串。返回值是CSS选择器匹配的第一个元素，一个HTMLElement对象；如果没有匹配到，返回一个null
获取匹配的多个元素：document.querySelectorAll('元素')，返回值是匹配的NodeList对象集合，这个集合有长度有索引号，但是没有pop(), push()等数组的方法
#### 操作元素内容
元素innerText属性：将文本内容添加/更新到目标位置，是纯文本，不经过浏览器解析（也就是说如果添加的是标签只会显示出标签的文本）
元素innerHTML属性：和innerText功能一样，但是是可以解析标签的。如果标签多可以用模板字符串
#### 操作元素样式
用对象.style.样式属性直接修改，后面跟的是字符串。一定要跟单位。带横杠的可以采用小驼峰命名法来使用属性
操作类名操作CSS：如果修改的样式比较多，可以写一个类然后套在标签上。元素.className = '类名'
通过classList操作类控制CSS：追加类 add() 类名不加点，字符串；删除类 remove() 类名不加点，字符串；切换类 toggle() 有就删掉，没有就加上（开关）
#### 自定义属性
标准属性：标签天生自带的属性，可以直接用点来访问
自定义属性：在标签上一律以data-开头，在DOM对象上一律以dataset对象方式获取
#### 定时器函数
启动：setInterval(函数，间隔时间)，函数可以是匿名函数，也可以是定义过的函数。如果是定义过的函数，在使用setInterval函数的时候直接传入函数名字就可以了，如果后面加括号就是调用一次这个函数。所以应该直接传入函数名字作为参数。定时器函数会有一个返回值，返回的是当前定时器在整个页面中，是第几个定时器（会变）
关闭：clearInterval(计时器id)
## 事件监听
#### 事件监听
元素对象.addEventListener('事件类型', 要执行的函数)
事件监听三要素：事件源（哪个DOM元素），事件类型（用什么方式触发的），事件要调用的函数
#### 事件类型
鼠标触发：click 点击，mouseenter 鼠标移入某个元素上方，mouseleave鼠标移出某个元素上方
焦点事件：focus 获得焦点，blur 失去焦点
键盘事件：keydown 键盘按下触发，keyup 键盘松开触发
文本事件：input 用户输入事件
#### 事件对象
事件对象也是个对象，这个对象存有事件触发时的相关信息。它在事件绑定的回调函数中的第一个参数中。元素.addEventListener('', function(event){})，这个event就是事件对象
type：获取当前的事件类型
clientX/clientY：获取光标相对于浏览器可见窗口左上角的位置
offsetX/offsetY：获取光标相对于当前DOM元素左上角的位置
key：用户按下的键盘键的值
#### 环境对象
环境对象：指的就是函数内部特殊的变量this，它代表当前函数运行时所处的环境。比如window.console.log()的this就是window；而如果我给一个button标签添加一个click事件，在这个click事件中，this就是button按钮。大概来讲，谁调用了函数，this就指向谁
#### 回调函数
如果将函数A作为参数传递给函数B，函数A就是回调函数。比如定时器函数里面必须传入的第一个函数参数，它就是个回调函数
## 事件流
#### 事件流和两个阶段
事件流指的是时间完整执行过程中的流动路径，其中包含捕获阶段和冒泡阶段，实际工作都是使用事件冒泡为主。简单理解来说，事件捕获就是从外到内执行，事件冒泡时从内到外执行
#### 事件捕获
从DOM的根元素开始执行对应的事件（从外到里），事件捕获需要写对应的代码才能看到效果。DOM.addEventListener(事件类型，事件处理函数，是否使用捕获机制)，对第三个参数传入true就是捕获，false就是冒泡（默认false）
#### 事件冒泡
当一个元素的事件被触发时，同样的元素将会在该元素的所有祖先元素中依次被触发。简单理解就是当一个元素触发事件后，会依次向上调用所有父级元素的同名事件
#### 阻止冒泡
因为函数是默认冒泡的，所以它在执行的时候很容易影响父级函数。因此如果想要它不影响父级函数，就要阻止事件冒泡拿到事件的对象：事件对象.stopPropagation()。它不仅可以在冒泡阶段阻断事件的流动传播，在捕获阶段也可以（不是阻止冒泡，是阻止事件流）
在某些情况下，我们也要防止默认行为的发生，比如提交注册的信息的时候，没有完全填写注册信息之前按下注册按理来说应该是阻止这次提交并跳转的。我们可以使用事件对象.preventDefault()来阻止默认行为的发生
#### 解绑事件
可以通过用null覆盖on事件的值来实现事件的解绑
如果是通过addEventListener添加的事件，必须使用removeEventListener(事件类型，事件处理函数，捕获或冒泡)来解绑。注意：匿名函数不能被解绑
#### 鼠标经过事件的区别
mouseover和mouseout会触发冒泡效果
mouseenter和mouseleave不会触发冒泡效果（推荐）
#### 事件委托
事件委托是利用事件流的特征解决一些开发需求的知识技巧，可以减少注册次数，提升程序性能。它利用事件冒泡的原理，给父元素注册事件，当我们触发子元素的时候，冒泡到父元素身上并触发父元素的事件
我们可以通过事件对象.target.tagName来获得真正触发事件的元素（这个tagName是大写的字符串）
## 其他事件
#### 页面加载事件
有时候我们需要等页面资源（如图片，外联CSS和js脚本等）加载完毕的时候才去触发一些事件
事件名 load：通过监听页面来等待所有资源加载完毕。window.addEventListener('load', function(){})
不光可以监听整个页面资源加载完毕，也可以针对某个资源，比如等待img加载完毕
有时候我们只需要等待HTML文档完全加载，而不需要等待样式表、图像等加载完毕才触发一些事件
事件名 DOMContentLoaded：通过监听页面DOM来等待HTML加载完毕。document.addEventListener('DOMContentLoaded', function(){})
#### 元素滚动事件
这是滚动条在滚动的时候持续触发的事件。很多网页需要检测用户把页面滚动到某个区域后做一些处理，比如说导航栏，返回顶部按钮等
事件名 scroll：通过监听整个页面的滚动。window.addEventListener('scroll', function(){})
给window和document添加scroll都可以，但是给window比较常用。元素内部也可以有滚动条，所以也可以给元素添加这个事件
scrollLeft和scrollTop可以获取被卷走的大小
document.documentElement可以获取html元素
在元素滚动事件中，如果要获取scrollTop和scrollLeft，一定要把他们放在元素滚动事件里面，否则将获取不到
#### 页面尺寸事件
窗口尺寸改变的时候触发的事件：resize
检测窗口尺寸：用document.documentElement.clientWidth可以找到窗口可见部分的宽度，clientHeight同理（不包含边框，margin，滚动条）
获取元素自身宽高offsetWidth和offsetHeight（包含元素自身设置的宽高、padding、border），获取出来的是个数值，是可视的宽高，如果元素是隐藏的那么获取出来的就是0
获取元素位置：获取元素距离自己定位父级元素的左和上的相对距离offsetLeft、offsetTop（只读）。父级元素有定位按照定位来，没有定位找最近的带有定位的祖先元素
## 日期对象
日期对象就是表示时间的对象，可以得到当前系统的时间
#### 实例化
new一个对象就是实例化.const date = new Date()，获取指定时间new Date('2008-8-8 08:30:00')。获取了指定时间就可以搞倒计时，比如到什么日子触发什么事件
#### 日期对象方法
获得年份 getFullYear()，获得月份 getMouth()，获得月份中的第几天 getDate()，获得星期几 getDay()，获得小时 getHours()，获得分钟 getMinutes()，获得秒 getSeconds()。其中，月份，星期，小时，分钟和秒取值都是从0开始的，月份从0-11，星期从0-6等。在用月份，星期的时候这种从1开始的都要加一
date.toLocaleString()可以直接获取日期和时间，toLocaleDateString()和toLocaleTimeString()分别可以获得日期和时间
#### 时间戳
时间戳是指1970年1月1日0点0分0秒起到现在的毫秒数，它是一种特殊的时间计量方式。可以用来倒计时
倒计时的剩余时间毫秒数 = 将来的时间戳-当前的时间戳。把剩余时间的毫秒数转换为年月日时分秒就可以做成倒计时
时间戳可以使用date.getTime()，+new Date()，Date.now()来获得。第三种只能获得当前的时间戳，前两种可以返回指定时间的时间戳
## 节点操作
#### DOM节点
DOM树里面的每个内容都是节点，有元素节点（所有的标签body，div等，html是根节点），属性节点（所有的属性如href），文本节点（所有的文本）
#### 查找节点
父节点查找：通过子元素.parentNode属性来查找，返回它最近一级的父节点，找不到返回null
子节点查找：通过父元素.childrenNode属性来查找，返回所有子节点，包括文本节点（空格、换行）、注释节点等
一般用父元素.children来查找，仅会获得所有元素节点，返回一个伪数组
下一个兄弟节点：nextElementSibling属性
上一个兄弟节点：previousElementSibling属性
#### 增加节点
一般情况下，我们新增节点首先要创建一个新的节点，然后把新创建的节点放到指定元素的内部
创建新的元素：document.createElement('标签名')
追加节点：父元素.appendChild(元素)可以在父元素的最后追加一个子元素；父元素.insertBefore(要插入的元素，插到哪个元素前面)，可以靠父元素.children[下标]来获得位置
#### 克隆节点
克隆一个节点需要先复制原有的节点然后把复制出来的节点放入指定的元素内部
元素.cloneNode(布尔值)，这个参数如果为true则代表会连着后代节点一起克隆，若为false则不包含后代节点（默认为false）
例：元素.appendChild(元素.children[下标].cloneNode(true))
#### 删除节点
在js的原生DOM操作中，要删除元素必须通过父元素删除：父元素.removeChild(元素)，如果不存在父子关系就不能删除。删除节点和隐藏节点（display:none）是有区别的
## M端事件
M端就是移动端，它有一些特殊的事件比如触屏事件touchstart触摸到一个DOM元素时触发，touchmove在一个DOM元素上滑动时触发，touchend从一个DOM元素上移开时触发
## JS插件
可以从官网，在线演示，使用流程文档，APi文档等学习使用各种插件
下载下来的包可以从package里找css，js等按需求复制放到项目里面
Swiper插件可以用来制作移动端适配
## Window对象
#### BOM（浏览器对象）
Browser Object Model 浏览器对象模型，BOM里面包含着DOM。window包含navigator，location，document，history，screen。
window对象是个全局对象，是JS中的顶级对象。所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法
#### 定时器-延时函数
setTimeout(回调函数，等待的毫秒数)
清楚延时函数：clearTimeout(timer)，timer是setTimeout函数返回的值，和定时器函数一样
#### JS执行机制
JS从上到下执行代码，JS有两个引擎，一个渲染引擎解析css，一个V8引擎解析js
JS是单线程的，同一时间只能做一件事，前一个任务结束才会去执行下一个任务。为了解决这个问题，H5提出Web Worker标准，允许JS脚本创建多个线程。于是JS就出现了同步和异步。其本质区别是各个流程的执行顺序不同
同步任务：同步任务都在主线程上执行，形成一个执行栈
异步任务：JS的异步是通过回调函数实现的。一般而言异步任务有三种类型，普通事件（click、resize等），资源加载（load、error等），定时器（setInterval、setTimeout等），异步任务相关的添加到任务队列（消息队列）中。虽然同步任务在执行栈，异步任务在任务队列，但是JS是没有堆和栈的，它们只是叫这个名字
执行机制：JS先执行栈中的同步任务，异步任务放入任务队列中，一旦执行栈中的同步任务执行完毕，系统就会按顺序读取任务队列中的异步任务，然后被读取的异步任务就进入执行栈开始执行，执行栈里没了任务就会又去任务队列里读取任务。由主线程不断地重复获得任务、执行任务、再获得任务、执行任务，这叫事件循环
JS是单线程的不能同时处理异步任务，所以JS会把需要处理的异步任务提交给对应的异步进程让浏览器处理，浏览器是可以多线程的，比如ajax（网络模块），DOM事件（DOM模块），定时器函数和延时函数（timer模块）等，异步进程在浏览器执行后（比如定时器到时间了），就会给任务队列添加相应的回调函数，然后等JS再读取任务的时候就会完成这个任务
## location对象
它拆分并保存了url地址的各个部分
#### 常用的属性和方法
href属性可以获取完整的url地址，对其赋值时可以跳转地址。最经典的使用就是location.href = '地址'，来跳转页面
search属性获取地址中携带的参数，可以返回地址中问号后面的部分
hash属性获取地址中的哈希值，可以返回地址中井号后面的部分
reload方法用来刷新当前页面（f5），对其传入true参数表示强制刷新，此时相当于crtl+f5
## navigator对象
该对象记录了浏览器自身的相关信息
#### 常用属性和方法
通过userAgent检测浏览器的版本和平台（比如验证是安卓还是苹果）
## history对象
该对象主要管理历史记录，与浏览器地址栏的操作相对应，如前进、后退、历史记录等
后退 back()，前进 forward()，前进或后退 go(参数) 参数如果是1就是前进1个界面 如果是-1就是后退1个界面
这个对象实际开发的时候比较少用，会在一些OA办公系统里面见到
## 本地存储
H5提出了相关规范：数据存储在用户浏览器中，设置和读取方便、页面刷新不丢数据，容量较大，sessionStorage和localStorage约有5M。存储在浏览器的Application可以看，本地存储只能存储字符串数据类型
#### 本地存储分类
localStorage可以将数据永久存储在本地（用户），除非手动删除，否则关闭页面之后再打开也有。它可以多页面共享（同一浏览器），以键值对的形式存储应用
存储、修改数据：localStorage.setItem('key', 'value')
读取数据：localStorage.getItem('key')
删除数据：localStorage.removeItem('key')
sessionStorage可以将数据存储在浏览器窗口内，它的生命周期直到关闭浏览器窗口，同一个页面下的数据可以共享，也是以键值对的形式存储，用法和localStorage基本一样
#### 存储对象
本地只能存储字符串，不能存储对象。所以我们可以把对象转换为JSON字符串格式再存储就可以了：JSON.stringify(object)。然后用的时候再转换回对象：JSON.parse(object)
#### 数组map和join方法
map可以遍历数组处理数据，并且返回新的数组。对map方法传入函数，该函数可以对该数组的所有元素进行处理，返回的就是处理完之后的数组。map也叫映射，指的是两个元素的集之间元素相互的对应的关系。map的重点在于它有返回值，与其类似的
forEach方法没有返回值
join方法用于把数组中的所有元素转换成一个字符串。对join方法传入一个参数，这个参数会出现在数组元素之间，如果是个空字符串（''）那么数组元素之间不会有任何字符；如果什么都不传入默认是逗号。
应用：比如给出一组对象数组，我们可以通过map方法给对象内的内容添加标签，然后再通过join方法把map方法返回的数组来拼接出来得到字符串，最后通过innerHTML输出给页面并渲染
## 作用域
作用域（scope）规定了变量能够访问的范围，离开了这个范围变量就不能被访问
#### 局部作用域
局部作用域分为函数作用域和块作用域
函数作用域：在函数内部声明的变量只能在函数内部被访问，外部无法直接访问，函数的参数也是函数内部的局部变量，不同函数内部声明的变量无法互相访问，函数执行完毕后，函数内部的变量会被释放
块作用域：在JS中用{}包裹的代码称为代码块，代码块内的变量外部有可能无法访问。let声明的变量会产生块作用域，var不会产生块作用域，const声明的常量也会产生块作用域，不同的代码块之间的变量无法互相访问
#### 作用域链
作用域链本质上是最底层的变量查找机制，在函数被执行的是时候，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域。就像冒泡一样
嵌套关系的作用域串联起来就形成了作用域链，相同作用域链中按照从小到大的规则查找变量，子作用域能访问父作用域，父作用域无法访问子作用域
#### 垃圾回收机制（Garbage Collection, GC）
JS中内存的分配和回收都是自动完成的，内存在不使用的时候就会被垃圾回收器自动回收
内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
内存使用：读写内存，使用变量、函数等
内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存
内存泄漏：程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏
全局变量一般不会回收（直到关闭页面），一般情况下局部变量不用了就会被自动回收掉
栈：由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面
堆：一般由程序员分配释放，若程序员不是放，由垃圾回收机制回收。复杂数据类型放到堆里面
#### 垃圾回收算法
引用计数法：要判断内存是否是不再使用的，就要看一个对象是否有指向它的引用，没有就要回收对象。IE用这个，现在不多了
算法：跟踪记录被引用的次数，被引用了就加一，不引用了就减一，直到记录的引用个数为0就释放。
这个算法存在致命的问题，如果有两个对象相互引用，那垃圾回收器永远不会回收它们，就会出现内存泄漏（嵌套引用/循环引用）

标记清除法：要判断内存是否是不再使用的，可以看它是不是个无法被到达的对象。
算法：从根部（JS中的全局对象）出发，定时扫描内存中的对象，如果能从根部到达某个对象就说明这个对象还是在使用的。而如果不能从根部出发到达的对象就是不再使用的，会被标记并回收
#### 闭包（Closure）
一个函数对周围状态的引用捆绑在一起，内层函数中访问到它外层的函数的作用域。简单来讲就是闭包=内层函数+外层函数的变量，内层函数用到了外层函数的变量才能叫闭包
闭包可以封闭数据，提供操作，让外部也可以访问函数内部的变量
```javascript
function outer(){
  let a = 10
  function fn(){
    console.log(a)
  }
  return fn
}
const fun = outer()
fun()
// 在这里面，outer函数返回了一整个的fn函数，而这个fn函数是和outer函数的变量组成了闭包，所以这个返回的fn函数也可以使用闭包中的a变量，也就是说我们可以通过闭包操作可以让函数外部访问到函数内部的变量
```
闭包可以实现数据的私有，把变量放在函数里面就可以让外部无法访问到这个变量，同时我们也可以通过闭包访问到这个变量，实现数据的私有化
#### 变量提升
变量提升允许变量在声明之前就被访问（只能在var出现），在代码执行之前先去检测当前作用域下所有var声明的变量，先把它们全部提到当前作用域的最前面。只会提升这个声明，不会提升整个声明+赋值操作，直接访问一个声明没有赋值的变量就会返回undefined
let/const声明的变量不存在变量的提升，而且变量提升只会提升到相同作用域中。我们在实际开发中应该先声明再访问
## 函数进阶
#### 函数提升
函数提升和变量提升比较类似，就是说看起来函数在声明之前就可以被调用。函数提升会把所有的函数声明提升到当前作用域的最前面。只提升函数声明，不提升函数调用
#### 函数参数
动态参数：arguments是函数内部内置的伪数组变量，它包含了调用时传入的所有实参，它只存在于函数中
剩余参数：剩余参数允许我们把一个不定数量的参数表示为一个数组，用法就是`...参数名`，然后调用参数就行了。这个...是个语法符号，置于最后一个函数形参之前，用来获取多余的实参，借助...获取的剩余实参是个真数组。我们最好多用剩余参数。伪数组是个对象，它用字符串来当索引，长度不可变，没有数组的方法，而且要用for key in arr来拿到键来遍历
展开运算符（...）：可以将一个数组进行展开。展开运算符不会修改原数组，可以用来求数组最大最小值，合并数组等。比如`Math.max(...arr)``arr = [...arr1, ...arr2]`
#### 箭头函数
箭头函数可以让函数写法更加简短而且不用绑定this，语法也比普通函数表达式更简洁，可以用来放在匿名函数的地方。语法`()=>{}`；如果函数只有一个参数，可以省略小括号，比如`x=>{}`；如果函数体只有一行语句，可以省略大括号`x=>x+x` （甚至还能省略return...）
加括号的函数体返回对象字面量`uname=>({uname:uname})`，这个也可以直接返回对象，不过要加小括号，因为函数不知道这个大括号是函数体的大括号还是对象的大括号
普通函数有arguments动态参数，但是箭头函数是没有arguments动态参数的，不过我们可以给它传剩余函数。
普通函数在被调用的时候会根据是被谁调用的来自动定义它的this，而箭头函数不会创建自己的this，只会根据作用域链找到上一层的this。
当然，如果我们需要使用到this来调用当前的对象的时候，还是不太能用箭头函数的，比如在我们DOM事件回调函数里面，我们可能需要回调函数操作这个DOM对象，这个时候我们还是不用箭头函数的好
## 解构赋值
#### 数组解构
数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法
`const [a, b, c] = arr[1, 2, 3]`
赋值运算符左侧的[]用于批量声明变量，右侧数组的单元值将被赋值给左侧相对应的变量，也就是说变量的顺序对应着数组单元值的位置依次进行赋值操作
JS里有一些必须加分号的情况比如立即执行函数，而数组解构的语句中，以数组开头，特别是前面有语句的一定要在解构前加分号
变量多，单元值少：多余出来的参数返回的就是undefined。我们可以设置默认值来避免undefined的出现
变量少，单元值多：只会依次赋给相对应的数据，多出来的单元值就多出来了。当然，这些多出来的单元值可以用剩余参数来接收
我们也可以按照我们的需求，忽略某些返回值来隔开单元值赋值。解构当然也支持多维数组，可以对某个变量传入一个数组，解构里面也能套解构（传入对象的时候可能有用）
#### 对象解构
对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法
`const user = {uname: 'name', age: 18}; const {uname, age} = user`
赋值运算符左侧的大括号用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量。对象属性的值将被赋值给属性名相同的变量，注意解构的变量名不要和外面的变量名冲突，否则会报错。对象在大括号中找不到变量名一致的属性时将会被赋值undefined。
如果我们想要给解构的对象一个名字，我们可以把它像对象一样处理，什么值：赋值给谁
`cosnt {uname: username, age: userage} = {uname: 'name', age: 18}`
当然，数组对象也可以解构：
`const [ {name, age} ] = [ {name: '123', age: 6} ]`
多级对象也可以解构，多级解构的过程中，内部的对象可以再当成一个对象解构嵌套在多级解构里面，这样就能体现多级解构了 。当然也有多级对象数组的解构
```javascript
const pig = {
  name: '小孩',
  family: {
    mother: '妈妈',
    father: '爸爸',
    sister: '妹妹'
  },
  age: 6
}

const {name, family: { mother, father, sister }, age} = pig
```
#### forEach
forEach()方法用于调用数组的每个元素，并将元素传递给回调函数：被遍历的数组.forEach(function(当前数组元素item, 当前数组元素下标index){函数体})，当前数组元素是必须要的，下标可选
#### 筛选数组filter方法
filter()方法创建一个新的数组，新的数组中的元素是通过检查指定数组中符合条件的所有元素。主要就是用来筛选数组中符合条件的元素，并且返回一个筛选之后的数组。它的用法和map类似：
`arr.filter(function(item, index){ return item > 20 })`
## 深入对象
#### 创建对象的三种方式
利用对象字面量创建对象：`cosnt o = { name: 'uname' }`（推荐）
利用new Object实例化一个对象：`const o = new Object({ name: 'uname' })`
利用构造函数创建函数（new Object其实是系统给的一种构造函数）：构造函数是一种特殊的函数，主要用来初始化对象。常规的{...对象体}语法允许创建一个对象。然而，如果我们想要连续创建对象是要多次实例化对象的。然而我们可以协议中构造函数来快速创建多个类似的对象。为构造函数传入参数，可以创建结构相同但是值不同的对象
```javascript
  function Pig(name, age, gender) {
    this.name = name
    this.age = age
    this.gender = gender
  }
  const o = new Pig('uname', 18, 'man')
```
构造函数有两个约定：它们的命名用大写字母开，只能用new操作符来执行
使用new关键字调用函的行为被称为实例化，实例化构造函数的时候没有参数可以省略小括号。构造函数内部不用写return，返回的自动就是新创建的对象；如果写了return，自己写的return是无效的。new Object()，new Date()也是构造函数的用法
实例化的执行过程：创建新对象->构造函数里的this指向新对象->执行构造函数代码，通过this添加新的属性->返回新的对象
#### 实例成员 & 静态成员
实例成员是通过构造函数创建的对象（实例对象），实例对象中的属性和方法被称为实例成员（分别就叫实例属性和实例方法）。构造函数创建的实例对象彼此独立，互不影响。比如给A添加一个新的属性或者方法，不会对B产生任何的影响
静态成员是构造函数的属性和方法（分别叫静态属性和静态方法），静态成员只能通过构造函数自己来访问，静态方法中的this指向的是当前的构造函数
## 内置构造函数
字符串、数值、布尔等基本类型都有专门的构造函数，这些我们称为包装类型。JS几乎所有的数据都可以基于构造函数创建。然而，简单数据类型也有属性（string.length），甚至方法（number.toFixed()保留几位小数），是因为JS底层把简单数据类型包装成了复杂数据类型
引用数据类型：Object，Array，RegExp（正则），Date等
包装类型：String，Number，Boolean等
js中字符串、数值、布尔都具有对象的使用特征，是因为它们都是js底层用Object构造函数包装出来的，所以又叫包装类型
#### Object
Object是内置的构造函数，用于创建普通对象。推荐使用字面量的方式声明对象而不是用Object构造函数
Object.keys：Object静态方法，获取对象中所有的属性（键），返回的是一个数组
`const arr = Object.keys(o)`
Object.values：相应的，values可以获取对象中所有的属性值并返回一个数组
Object.assign：静态方法，可以拷贝对象，在对象经常使用的场景给它添加属性
`Object.assign(obj, o)`可以把o拷贝给obj
`Object.assign(o, { gender: '男' })`可以把gender属性添加给o
#### Array
创建数组建议用字面量创建而不用Array构造函数
Array常见的实例方法有：forEach() 遍历数组（不返回数组，常用于查找遍历），filter() 过滤数组（返回筛选后满足条件的新数组），map() 迭代数组（返回处理之后的新数组），reduce() 累计器（返回累计处理的结果，常用于求和等）
reduce：`arr.reduce(function(){}, 起始值)``arr.reduce(function(上一次值prev，当前值current){}, 初始值init)`，如果没有起始值则上一次值为数组的第一个数组元素的值，每次循环都把返回值作为下一次循环的上一次值，如果有起始值九八起始值作为第一个上一次值。用到对象里的数据的时候，一定要把起始值设置为零（用起始值就不为零），因为prev其实是上一次调用这个回调函数的结果，而并非是个特定的值或对象
join：数组元素拼接为字符串，返回一个字符串
find：查找元素，返回符合测试条件的第一个数组元素，如果没有符合条件的则返回undefined
every：检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回true，否则返回false
some：检测数组中的元素是否满足指定条件，如果数组中有元素满足条件返回true，否则返回false
concat：合并两个数组，返回生成新的数组
sort：对原本的数组单元值进行排序
splice：删除或替换原数组单元
reverse：反转数组
findIndex：查找元素的索引值
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40611437/1721470418675-53be0385-0598-44df-b322-0bc854a1c170.png#averageHue=%23e6e2df&clientId=u4e6812ac-3827-4&from=paste&height=338&id=u7b4bed3a&originHeight=507&originWidth=678&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=261594&status=done&style=none&taskId=u5d4e60d6-2b13-4de7-be8c-d3a22920103&title=&width=452)
静态方法Array.from()可以把伪数组转换为真数组
#### String
split('分隔符')：将字符串拆分成数组
substring(需要截取的第一个字符的索引, 结束的索引号（可选）)：截取字符串
startWith(检测字符串，检测位置索引号（可选）)：检测是否以某字符开头
includes(搜索的字符串, 检测位置索引号（可选）)：判断一个字符串是否包含在另一个字符串中，根据情况返回true或false
toUpperCase：将字母转换成大写
toLowerCase：将字母转换成小写
indexOf：检测是否包含某字符
endsWith：检测是否已某字符结尾
replace：替换字符串，支持正则匹配
match：查找字符串，支持正则匹配
#### Number
toFixed()：设置保留小数位的长度
## 两种编程思想
#### 面向过程
面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个依次调用即可。就是说按照我们分析好的步骤解决问题
它的性能比面向对象要高，比较适合与硬件联系很紧密的东西，比如单片机。不过缺点就是不好维护，很多代码不能复用和拓展
#### 面向对象
面向对象就是把事务分解成一个一个的对象，然后由对象之间分工合作解决问题。每个对象都是功能中心，具有明确的分工，灵活、代码可复用、容易维护和开发等优点，而且适合多人合作的大型项目
面向对象具有封装性，继承性，多态性的特点，耦合性比较低
## 构造函数
封装是面向对象思想中比较重要的一个部分，js面向对象可以通过构造函数实现封装。同样地将变量和函数组合到了一起并能通过this实现数据的共享，所不同的是借助构造函数创造出来的实例对象是彼此不影响的
简单的通过this来构造变量很好用，但是会浪费内存。很多相同的函数都会被重复地构造到堆里，然而它们的效果是一样的，所以重复构造当然会浪费很大的内存
## 原型
原型可以解决构造函数中浪费内存的问题
首先，构造函数通过原型分配的函数是所有对象共享的。JS规定，每个构造函数都会有一个prototype属性来指向另一个对象，所以我们也称之为原型对象。这个对象可以挂载函数，多次对象实例化并不会多次创建原型函数，这样可以节约内存。因此，我们可以把那些不变的方法直接定义在prototype对象上，这样所有实例化这个对象的实例就可以共享这个方法。注意，构造函数和原型对象中的this都指向的是实例化的对象

#### constructor属性
每个原型对象里面都有这个属性，该属性指向该原型对象的构造函数，可以找到它到底是哪个构造函数的原型对象。如果我们要为了简便添加一些方法而直接写一个对象，里面装满方法让后赋值给prototype，这种情况我们就没有了constructor，因此要在这个对象里面再添加上constructor
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40611437/1721544856941-ebc88f58-ffcf-4ec2-8201-ae9370ad6578.png#averageHue=%232c2f38&clientId=u011fe6c8-0622-4&from=paste&height=269&id=u5a61a5de&originHeight=404&originWidth=746&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=126751&status=done&style=none&taskId=uf846fa9e-9edf-4d06-9a41-b18e9849734&title=&width=497.3333333333333)

#### 对象原型
对象都会有一个\_\_proto\_\_指向构造函数的prototype，对象之所以可以使用protype的属性和方法就是因为有\_\_proto\_\_的存在。这个\_\_proto\_\_是JS的非标准属性，它又可以写作[[prototype]]，用来表明当前的实例对象指向哪个原型对象prototype。\_\_proto\_\_对象原型中也有一个constructor，指向的是创建该实例对象的构造函数
#### 原型继承
继承也是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JS中大多是借助原型对象来实现继承的，给原型prototype追加我们要继承的东西就可以了。然而，如果我们想要继承同一种对象，我们不能直接去给不同的对象继承同一个对象，这样如果分别修改它们的原型，修改都会应用到所继承的对象上。那么我们就可以通过构造函数来使继承的对象每次都不一样，这样就可以避免这个问题
#### 原型链
基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系也是一种链状的结构，我们将对原型对象的链状结构关系称为原型链
只要是对象就会有\_\_proto\_\_，而普通构造函数实例化出来的对象，它的原型对象的\_\_proto\_\_就会指向Object的prototype，当然Object的原型对象也有\_\_proto\_\_，只不过它指向的是null
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40611437/1721550502134-a305b79a-4fe3-47c1-982f-b60086869f85.png#averageHue=%23f9f9f9&clientId=u011fe6c8-0622-4&from=paste&height=398&id=O3L6z&originHeight=597&originWidth=1558&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=84288&status=done&style=none&taskId=ub35d237c-5c49-444a-b040-d023811dae6&title=&width=1038.6666666666667)
原型链查找规则：

1. 当访问一个对象的属性和方法的时候，首先查找这个对象自身有没有这个属性
2. 如果没有就查找他的原型（\_\_proto\_\_指向的prototype原型对象）
3. 如果这里也没有那就查找原型对象的原型（即找Object的原型对象）
4. 以此类推一直找到Object的最顶（null）

\_\_proto\_\_对象原型的意义就是在于为对象成员查找机制提供一个路线，我们可以用instanceof运算符检测构造函数的prototype属性是否出现在某个实例对象的原型链上
## 深浅拷贝
浅拷贝和深拷贝都是只针对引用类型，简单类型不需要拷贝，直接赋值就可以，不会有问题
#### 浅拷贝
如果我们想要获得一个对象的拷贝，我们可以直接给一个赋值操作，但是这样的话实际上只是把地址给赋过去了，那么如果我对这个对象进行更改原本的对象也会被改变。
为了解决这种问题我们可以用浅拷贝，浅拷贝只是拷贝地址。常见的方法有：拷贝对象 Object.assign() / 展开运算符{...obj} 拷贝对象；拷贝数组 Array.prototype.concat() / [...arr]
然而，浅拷贝还是会有这样的问题。如果我们在对象里嵌套一个对象obj，再浅拷贝出来一个新的对象，我们对这个新对象中的对象obj进行操作还是会修改原本对象中的对象obj。所以浅拷贝只是拷贝外面这一层。浅拷贝把内部的对象的值拷贝给新对象，然而这个内部对象的值是它的地址，因此拷贝过去之后对它进行操作还是会操作到原本的对象
所以浅拷贝适合单层（全都是简单数据类型）
#### 深拷贝
深拷贝拷贝的是对象而不是地址，常见的方法有递归拿数据，loadash/cloneDeep，JSON.stringify()等
函数内部自己调用自己就是递归函数，它的作用和循环差不多。递归很容易出现栈溢出的错误，因此要找好return的各种条件![image.png](https://cdn.nlark.com/yuque/0/2024/png/40611437/1721564643422-d73f3dde-a870-4a3c-b352-24ac5163fbdd.png#averageHue=%232b2e37&clientId=u148f71dd-c023-4&from=paste&height=627&id=ue0602b32&originHeight=941&originWidth=1174&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=390822&status=done&style=none&taskId=ua9276b59-0d86-4761-aa01-6a3c4e565bc&title=&width=782.6666666666666)
JS库中的lodash中cloneDeep内部实现了深拷贝，直接引入lodash并用函数就可以实现深拷贝了
用JSON.parse(JSON.stringfy(obj))来把原来的对象创建成一个新的对象，这样就不会有浅拷贝的问题了
## 异常处理
异常处理是指预估代码执行过程中可能发生的错误，然后最大程度地避免这个错误的发生
#### throw
throw可以抛出异常信息，并且中断程序的运行，它后面跟的是错误提示信息。我们可以用Error对象配合throw，可以获得更详细的错误提示信息
#### try/catch捕获错误信息
try尝试：可能发生错误的代码写到try里面
catch拦截：catch要加一个形参，里面保存了浏览器提供的错误信息。形参有个message属性可以打印出来获得错误信息。catch不会中断程序的执行，所以可以在它的末尾加return就能结束程序；或者我们可以throw new Error()
finally最终：不管程序对不对，都会执行这一段代码
#### debugger
和断点是一个作用，如果我们的代码已经比较长了为了方便调试我们可以提前在代码里写入debugger
## 处理this
#### this指向
首先在普通函数里面，普通函数的调用方式决定了this的值，谁调用函数this就指向谁。如果普通函数额没有明确的调用者的时候默认是window调用的函数，而如果是严格模式（`use strict`）则是undefined
而箭头函数根本就不存在this，不过箭头函数会默认帮我们绑定一个外层this，所以在箭头函数中this的值和外面一层的this是一样的，引用的就是最近作用域中的this。如果外层函数没有作用域，箭头函数会一层一层查找this，直到找到一个this
注意：开发的时候如果我们要写箭头函数一定要注意是不是要用到this，比如事件回调函数中this是window，然而如果我们要用到这一层的this比如DOM事件回调函数，我们就应该写一个普通函数；另一方面，基于原型、构造函数的面向对象编程也不推荐用箭头函数，它们都要指向当前的实例
#### 改变this
有几个方法可以动态指定普通函数中this的指向
call：使用call方法可以调用函数的同时指定被调用函数中this的值`fn.call(thisArg, arg1, ...)`，第一个参数就是函数运行的时候指定的this，这个方法返回的就是函数的返回值
apply：用它调用函数也可以指定this值`fn.apply(thisArg, [argsArray])`，thisArg就是函数运行的时候指定的this，argsArray是它传递的值，必须包含在数组里面。这个apply主要是和数组有关系，比如使用Math.max()等![image.png](https://cdn.nlark.com/yuque/0/2024/png/40611437/1721566402013-950bcd5d-3803-4a31-8ce7-1456f78efab6.png#averageHue=%232c3039&clientId=u148f71dd-c023-4&from=paste&height=181&id=ubc3012f3&originHeight=271&originWidth=1443&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=211406&status=done&style=none&taskId=ua7c661ee-71b9-4685-af9b-ef349f85f49&title=&width=962)
bind：bind不会调用函数，但是它会改变函数内部this的指向，它的用法和call相似，然而返回的是制定出来的this和参数改造出来的原函数的拷贝。如果我们只想改变this的指向而不想调用这个函数的时候，就用bind，比如改变定时器内部this的指向
## 性能优化
#### 防抖debounce
防抖就是单位时间内频繁触发事件只会执行最后一次，如果函数里面存在大量消耗性能的代码，比如DOM操作，数据处理等容易造成卡顿的东西，我们就可以用防抖来提升性能
比如搜索框搜索输入，我们只需要拿用户最后一次输入的请求；又比如说手机号验证、邮箱验证。
我们可以通过lodash提供的防抖来处理，当然也可以自己手写一个防抖函数。防抖的核心思路其实就是利用定时器setTimeout来实现，当事件触发的时候先判断是否有定时器，如果有定时器就先清除定时器；如果没有定时器就先开启定时器，然后在定时器里面调用要执行的函数
#### 节流throttle
节流是单位时间内频繁触发事件只会执行一次，比如mousemove、rsize、scroll等。当然还是用lodash或者手写，也可以用定时器来写节流代码，只不过每次执行函数就是先判断是否有定时器，如果有定时器则不开启新的定时器，如果没有就开启新的定时器。不过，定时器内部要在执行完后自动清空定时器
