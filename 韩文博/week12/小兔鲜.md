## VUE3复习
相比vue2代码量减少了，分散式维护转为了集中式维护，有良好的TreeShaking可以按需引入需要的包，打包后的程序体积更小，组件初始化更高效
#### 关键文件

- vite.config.js：项目的配置文件，是基于vite的配置
- package.json：项目包文件，核心依赖项变成了Vue3.x和vite
- main.js：入口文件createApp函数创建应用实例
- app.vue：根组件，是SFC单文件组件 script-template-style
- index.html：单页入口，提供#app挂载点
#### setup
setup在beforeCreate钩子之前，可以直接定义数据和函数等，然后按照对象的方式组合起来return给使用者。可以通过语法糖的封装自动实现包装和暴露，但是不再支持this
#### 响应式
把常规的数据交给响应式函数包装后，可以在数据发生改变的时候也对视图进行更新。对象可以交给reactive，简单类型或对象可以交给ref，用的时候首先引入。脚本区域修改ref产生的响应式数据的时候，要通过.value来访问，不过模板区域可以直接用
#### 计算属性computed
引入计算属性函数，在回调函数中return我们要得到的值。计算属性中不应该有“副作用”，也就是说计算属性就拿来计算，不要拿来做其他的事情，其他的事情应该用watch来做。以及避免直接修改计算属性的值，它是只读的
#### watch
侦听一个或多个数据的变化，数据变化的时候执行回调函数，有immediate参数（立即执行）和deep（深层监听）
watch函数传入ref参数不需要加.value，程序会自动帮我们处理。如果我们想监听多个数据源，不管哪个数据源变了都去处理，可以传数组的格式，把想要监听的数据都放进去，然后new和old也一样的传对应的数组就行
immediate可以在监听器创建的时候就触发一次回调，后面响应式数据变化了也继续执行回调函数。deep可以让watch监听嵌套在深层的数据，watch默认浅层监听。有时候我们需要监听对象的某一个精确的属性，而不是所有的属性，可以在第一个参数写成函数，然后在里面return想要监听的属性就行。`watch(()=>{info.value.age}, ()=>{})`。deep只要打开就会进行递归遍历，所以如果能不用就不用，最好精确监听
#### 生命周期函数
用到哪个生命周期函数就导入哪个，然后直接传回调函数。beforeCreate和created转换成了setup，这两个函数中作用的东西直接写到setup就能用。还有onBeforeMount，onMounted，onBeforeUpdate，onUpdated，onBeforeUnmount，onUnmounted
生命周期函数可以执行多次，也就是说可以有多个onMounted等，多次执行时传入的回调会按照注册的顺序依次执行。比如如果本来组件里面就有一个onMounted，我们想要添加一些东西就可以新写一个onMounted防止把原来的函数破坏
#### 组合式API下的父传子
父组件中绑定属性，子组件中通过defineProps编译器宏函数来接受传过来的数据，编译器宏函数可以简化传递的过程
#### 组合式API下的子传父
父组件通过标签给子组件传事件函数，子组件通过$emit方法触发父组件传过来的函数
#### 模板引用
通过ref标识获取真实的dom对象或者组件实例对象。首先调用ref函数生成一个ref对象，然后通过ref标识绑定ref对象到标签，不过需要组件挂载完毕之后才能获取，所以可以放在onMounted函数
不过，默认情况下在语法糖里面组件内部的属性和方法是不开放给父组件的，也就是说直接拿只能拿到这个实例对象，所以我们应该把我们需要用到的属性和方法暴露出来，通过defineExpose编译宏指定那些属性和方法允许被访问
#### provide和inject
实现顶层组件向任意底层组件传递数据和方法，跨层组件通信。可以通过在顶层组件写provide函数提供数据，然后在底层组件写inject函数获取数据。但是注意，开发过程中谁的数据就交给谁修改。如果我们想从底层传给顶层一些信息，我们可以在顶层的provide提供一些函数参数在底层调用，然后传回去信息
## Pinia
vue专属的状态管理库，是Vuex状态管理工具的替代品。提供了更加简单的API，符合组合式风格的API，每一个store都是独立的模块，可以搭配TS提供更好地类型推断
`npm install pinia`，然后创建一个pinia实例（根store）并传递给应用
```typescript
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

const pinia = createPinia()
const app = createApp(App)

app.use(pinia)
app.mount('#app')
```
#### 计数器案例
先创建defineStore一个Store，然后在组件中使用这个store。可以符合组件式API
```typescript
export const useCounterStore = defineStore('counter', ()=>{
  const count = ref(0)
  function increment(){
    count.value++
  }
  return { count, increment }
})

//组件使用Store
<script setup>
  import {  useCounterStore } from '@/stores/counter'
  const counterStore = useCounterStore()
    //counterStore包含我们在Store里面return出去的属性和方法等
</script>
```
#### getters
getters相当于vuex的计算属性，所以Pinia的getters可以用computed函数进行模拟。当然这个getters也是需要在对象里面return出去才能被别的组件使用
#### action实现异步
action实现异步和组件中定义数据和方法的风格完全一致
```typescript
const API_URL = 'http://'127.0.0.1:8000/channels

const list = ref([])

const loadList = async()=>{
  const res = await axios.get(API_URL)
  list.value = res.data.data.channels
}

return {list} 
```
#### storeToRefs
使用这个函数可以辅助保持数据（state+getter）的响应式解构，因为直接结构ref会导致解构出来的的数据丢失响应式。`const { count, doubleCount } = storeToRefs(counterStore)`，这样解构出来的都是ref响应式数据。storeToRefs只负责数据的处理，不负责方法的处理，所以如果想解构出来方法可以直接解构（方法又不用响应式）
## 项目起步
#### 项目初始化
`npm create vue@latest`，添加Router、Pinia和ESLint，然后安装npm`npm install`。添加目录：API接口文件apis、组合函数文件夹composables、全局指令directives、全局样式styles、工具函数utils
#### 别名路径联想
在根目录下添加jsconfig.json文件，添加配置项
```javascript
{
  "compilerOptions": {
    "baseUrl": "./",
    "paths": {
      //当我们输入“@/”的时候，vsc会自动把src目录下的所有文件联想出来
      "@/*": [
        "src/*"
      ]
    }
  },
}
```
这样输入后进行联想出来的一串路径是不会自动转换成实际的路径的，而在vite.config里面的alias别名路径配置项才会负责把at符转换成实际路径
#### elementPlus
提供通用组件，如Dialog模态框。首先是安装`npm install element-plus --save`，然后采用按需导入`npm install element-plus --save`，配置vite.config
```javascript
// vite.config.ts
import { defineConfig } from 'vite'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

export default defineConfig({
  // ...
  plugins: [
    // ...
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ],
})
```
详细的内容应该多看官方文档
#### element+的主题定制
插件提供了一套颜色搭配，但是我们大部分情况需要自己来设计颜色搭配。可以采用scss变量替换方案`npm i sass -D`，然后给出定制样式的文件，在styles内部创建一个element文件夹，然后把我们定好的scss文件给到element里面，最后让element采用scss并拿到我们定好的scss文件
#### axios
安装`npm i axios`，然后配置基础实例（统一接口配置）：接口基地址，接口超时时间，请求拦截器，响应拦截器
```javascript
import axios from 'axios'

const httpInstance = axios.create({
  baseURL: 'http://pcapi-xiaotuxian-front-devtest.itheima.net',
  timeout: 5000
})

// axios请求拦截器
httpInstance.interceptors.request.use(config => {
  return config
}, e => Promise.reject(e))

// axios响应式拦截器
httpInstance.interceptors.response.use(res => res.data, e => {
  return Promise.reject(e)
})

export default httpInstance
```
然后，在api模块进行封装并测试
#### 路由设计
路由设计原则：找内容切换的区域，如果是页面整体切换就是一级路由；如果是在一级路由页的内部切换，则为二级路由
createRouter创建router实例对象
createWebHistory：创建history模式的路由
routes：配置path和component对应关系的位置
每一层路由都有一个路由出口，不要忘记检查路由出口是否添加。二级路由应该放在一级路由的children里面。默认选页可以把路由的path置空，这样当我们在浏览器里面访问子组件的时候，这个默认选页也会一起渲染
#### 静态资源引入
实际工作中的资源通常是由UI设计师提供的，如png、svg等，样式资源通常是指项目初始化的时候进行样式重置（如css自带的margin和padding等，这些自带默认的样式），常见的比如开源的normalize.css或者手写代码。
图片资源放在assets的images下，样式资源放在styles下
#### scss的自动导入
在项目里一些组件共享的色值会以scss变量的方式统一放到一个名为var.scss的文件中，正常组件中使用，需要先导入scss文件，然后再使用内部的变量。自动导入可以免去这个手动导入的步骤，直接使用内部的变量
首先新增一个var.scss文件，在里面存入色值变量。然后通过vite.config配置自动导入文件的代码
#### 静态模板搭建
实际开发的过程中通常会拿到一个ui设计稿，我们可以把稿的内容拆分为几个模块，如Nav导航区、Header、二级路由区、Footer等，然后再一个一个实现
#### 字体图标引入
引入都有多种引入方式，要看具体的内容文档。可以采用阿里巴巴矢量图标库等
#### 渲染一级导航
实际开发中会给出项目开发文档，我们可以根据接口文档封装接口函数，然后向数据列表发送请求，得到数据后就可以用v-for来渲染页面
#### 吸顶导航
我们的顶部导航需要在上下滚动后，到快看不见的时候可以展示出来一个吸顶导航，这样用户就可以随时切换页面。
首先准备吸顶导航组件，展示一整个顶部导航，然后在script中获取滚动距离，判断控制盒子展示还是隐藏
我们可以借助vueUse来实现获取滚动距离的功能，当然手写也可以。`npm i @vueuse/core`，用`const { y } = useScroll(window)`，这个y就是当前页面已经滚动的距离。然后根据实际情况使用展示的方法就可以，如script展示，style展示等，而在vue里我们可以用vue动态类控制来实现切换类名
#### pinia优化重复请求
如果我们直接用吸顶导航和普通顶部导航，我们明明展示的是相同的功能和数据，但是我们却要请求两次数据来渲染这两种导航，所以对于这种使用相同数据的区域，我们可以只请求一次然后把数据存放在pinia里面，然后两个导航再共用这些数据就可以了
我们如果给吸顶导航和普通顶部导航来触发这个请求，那么还是重复的，所以我们可以给它们的父组件来触发这个请求，然后存放到pinia里面，之后再下发给导航组件
## Home模块
#### 分类展示
实际开发的时候可以根据接口文档或者是存下来的数据来找一级路由和二级路由应该放在哪里，利用好`:key`和`v-for`等
#### 轮播图
点击向左向右进行轮播，不点击也会自动播放。我们可以手写轮播代码，也可以用element+的相关组件，之后获取相应的图片数据交给组件并渲染就可以了。在使用的时候一定要看接口文档来给属性赋值，不能凭经验写
#### 面板组件封装
组件封装可以解决复用问题和业务维护问题，如新鲜好物和人气模块在结构上非常相似，只是里面的内容不同，所以我们可以通过组件封装来实现复用结构的效果。核心思路就是把可复用的结构只写一次，然后把可能发生变化的部分抽象成组件参数（props和插槽）
首先我们不做任何结构的抽象，我们先准备好静态模板，然后从模板中抽象出来可变的部分如标题等，标题是纯文本可以抽象成prop传入，里面展示的内容是复杂的模板，我们要在模板内部再进行排版展示内容，所以应该抽象成插槽并传入
#### 新鲜好物和人气推荐实现
准备模板，定制Props和插槽，也要做好插槽的内容（接口+渲染）
#### 图片懒加载
有的网站页面会很长，而用户不一定会访问到下面的部分，所以我们可以通过懒加载优化来让一般看不到的图片只有进入视窗区域才发送图片请求。这样可以节约一点资源，减少图片资源请求
`<img v-img-lazy="item.picture" />`，我们写懒加载的指令img-lazy之后，给img绑定v-img-lazy就可以了。原理就是判断图片是否进入视窗区域（vueUse），然后检测图片监控是否生效，如果图片进入视窗则发送图片资源请求，最后测试图片资源是否发出。当然这种组件可以注册为全局组件等，也可以用指令钩子来指定这些组件什么时候启动
vueUse中useIntersectionObserver的函数作用可以检测某个元素是否进入视窗区域，第一个参数传target，第二个参数传回调函数，其中有一个isIntersecting的参数很重要，它就是用来判断是否进入视窗区域的参数
入口文件通常只做一些初始化的事情，不应该包含太多的逻辑代码，所以我们应该通过插件把懒加载指令封装为插件，而main.js入口文件只需要负责注册插件
而这里面还存在一个重复监听问题，useIntersectionObserver是一直存在对元素的监听的，我们需要在某些情况手动停止监听，防止资源浪费。比如本项目中，我们需要它监听图片区域是否进入视窗区域，而如果我们不进行处理，我们再第一次加载完图片后，再去访问视窗区域还是会发送图片请求。所以我们应该避免重复的请求
#### Product产品列表
常规的列表渲染，模板-封装接口-获取数据并渲染-调用懒加载
#### GoodsItem组件
很多业务模块中都需要用到相同的商品展示模块，我们可以封装起来重复利用。核心思想：把想要显示的数据对象设计为props参数，传入什么数据对象就显示什么数据。这种纯展示类的组件都这样设计
## 一级分类
#### 整体配置
导航需要给出一级分类的id，可以在路由中给path提供一个占位`path: 'category/:id'`，然后再组件中给RouterLink的to添加动态识别`:to="`/category/${item.id}`"`
#### 面包屑导航
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40611437/1724160588233-d3266974-5165-481c-a40c-a532ab17caca.png#averageHue=%23f3f2f1&clientId=uddddc31e-a5b0-4&from=paste&height=175&id=u58f49756&originHeight=262&originWidth=814&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=56010&status=done&style=none&taskId=uef895ea9-0be0-4667-9809-97fb1ab5d10&title=&width=542.6666666666666)
它的目的是为了让用户知道现在当前处于网站的哪个地方。步骤无非就是点到哪个网页就显示哪个网页的数据。模板-封装接口函数-使用路由参数调用接口获取数据-渲染。面包屑组件由两个组件组成，外层组件提供分隔符，如首页>居家的尖括号（当然别的也可以，如横杠、斜杠等），内层的组件就是导航项
为了获取当前页面的路由，我们可以写一个category组件的api，这次这个api需要传入id参数，我们可以把当前页面的路由传给这个api，这样它就可以反馈给面包屑导航并且展示出来。组件内部获取路由参数是用useRoute
#### banner轮播图
分类轮播图和首页轮播图的区别在于接口参数是不同的
#### 激活状态显示和分类列表渲染
导航栏上应该是我们当前页面在哪里，哪个导航块就应该亮起来。这个功能是比较简单的，因为RouterLink组件默认支持激活样式现实的类名，我们只要给active-class属性设置对应的类名就可以了。比如我们给`active-class="active"`，而在css里面就设置active的样式`active{...}`，这样就是激活这个组建的时候就同时给一个active类
而分类的数据我们只需要通过v-for遍历出来就行
#### 路由缓存问题
使用带有参数的路由的时候，我们需要注意当我们从一个一级路由转换到另一个一级路由的时候，相同的组件实例会被重复使用。因为两个路由都在渲染同一个组件，程序就会复用这个同样的组件，但是，这也就意味着它只会被创建一次，而生命周期也只会被调用一次。那么我们可以让组件实例不再复用，强制执行生命周期；又或者监听路由的变化，变化之后再执行相应的数据更新。
第一种方案只需要给RouterView添加key，以当前路由的完整路径为key绑定，如`RouterView :key="%route.fullPath" /`，这个添加key绑定v-for常用，但是也可以用来强制替换一个元素或者是组件（而不是复用），这样可以在适当的时候触发组建的生命周期的Hooks，也可以触发一些过渡；这种方案把整个实例都销毁重建了，所以组件里面的请求都会重新发送，这样就会浪费资源
另一种方案我们可以监听路由的变化，可以采用beforeRouteUpdate导航钩子，它可以在每次路由更新之前执行，在其回调函数中执行需要更新的数据业务逻辑就可以了。
#### 使用逻辑函数拆分业务
基于逻辑函数拆分业务是指把同一个组件中独立的业务代码通过函数做封装处理，提升代码的可维护性。首先我们要按照业务声明以use打头的逻辑函数-把独立的业务逻辑封装到各个函数内部-函数内部把组件中需要用到的数据或者方法return出去-在组件中调用函数把数据或者方法组合使用
## 二级分类
#### 整体配置
和一级分类与首页的关系类似，只是配置路由的时候要给category的path配置
#### 面包屑导航
封装接口-调用接口获取数据-渲染并测试
#### 二级分类基础商品列表
首先要实现列表的渲染-添加参数实现筛选功能-实现无限加载功能
列表渲染需要我们封装接口-准备参数-获取数据并渲染列表。
筛选功能的核心逻辑是点击标签，就切换筛选条件参数sortField，然后重新发送列表请求。当然还可以用RouterLink自带的active-class来实现激活功能。如果如果在业务逻辑实现筛选功能后点击标签没有进行筛选，是因为没有相应的筛选条件，实际开发中会有接口
无限加载功能其实就是不断获取新列表，然后再把新列表和老列表拼接起来的。可以用element+提供的v-infinite-scroll指令监听是否满足触底条件，满足触底条件就让页数参数+1来获取下一页的数据，然后获取新数据并做新老数据拼接和渲染，最后结束监听。如果加载完了没有数据了，发起请求拿回来的内容就为空，所以可以判断如果内容为空（内容数组长度=0）的话，就结束监听。当然实际开发的时候应该和后端对接好
#### 定制路由scrollBehavior
定制路由行为可以让我们在不同路由切换的时候自动滚动到页面的顶部，而不是停留在原本的位置。vue-router支持scrollBehavior配置项，可以指定路由切换时的滚动位置
## 详情页模块
#### 整体配置
创建详情页组件-绑定路由关系-绑定模板并测试。配置路由的时候仍旧是在相应的位置用占位符id占位，然后在展示的标签上绑定路径
#### 基础功能渲染
封装接口-调用获取数据-渲染。一定要看好接口到底有什么属性，pictures不能打成picture。以及有数组的属性，初始化的时候要用v-if判断要用到的下标是否有内容，或者用?.可选链等，因为不能访问空数组的下标
#### 热榜区
封装热榜组件-获取热榜数据-适配不同类别的热榜-适配内容
为了适配不同title的热榜，我们可以写props来传递热榜参数，并且写TYPEMAP+computed来造热榜参数和title名称的对应关系，之后在获取热榜的时候把热榜参数放出来就可以了
#### 图片预览组件
具有大图切换功能，也要有放大镜效果
大图切换功能我们可以写数组，维护一个数组图片列表，鼠标移进来就通过下标值获取对应图片并显示到大图的位置
放大镜效果就是小滑块跟随鼠标移动-滑块内的内容放大展示-鼠标移入可以控制滑块和移除隐藏大图显示。思路就是获取当前鼠标在盒子内的相对位置（useMouseInElement），计算有效移动范围和边界距离控制，然后控制滑块跟随鼠标
放大后大图的宽高是小图的两倍，当我们的放大镜向右移动的时候，大图在向左移动（视窗是不动的），因此数值是-2倍。而我们也需要当我们的鼠标不再小图范围内时，大图消失，可以判断鼠标是否在盒子内（isOutside）来展示滑块和大图（v-show）
有一点可以优化，如果我们的鼠标本来就不在盒子里，我们就不需要渲染这个放大镜组件
#### 组件props适配
我们的详情区域图片是不写死的，所以可以用props来获取图片列表
#### 总结
封装复杂交互组件的通用思路有：拆解功能-寻找核心实现思路，寻找关键技术（如用vueuse等）-逐个实现，逐个测试，逐个优化
#### SKU组件
存货单位stock keeping unit，或者叫库存单元，定义为库存管理中最小的可用单元。如纺织品中SKU通常表示规格、颜色、款式。本项目中SKU的作用就是产出当前用户选择的商品规格，为加入购物车操作提供数据信息
在实际开发中，对于第三方组件，我们应该重点看props和emit，props决定了组件接收什么样的数据，emit决定组件会产出什么数据。开发组件的时候要验证组件是否正常：传入必要数据看展示功能是否正常，点击规格选择看是否能正常产出数据
#### 通用组件统一注册为全局组件
根目录下的components目录下会有很多通用性组件，会在多个业务模块中共享，所以统一进行全局组件注册更好。我们可以定义一个完整的注册功能，然后再main.js里面注册一下
## 登录模块
登录功能主要是表单检验和登录登出业务
#### 表单检验
前端进行一些表单检验可以省去错误的提交，这样后端处理数据的时候就不需要也处理这些错误的数据了，可以节省接口压力。可以用element+按照组件要求配置参数。在使用这种第三方模板插件的时候我们可以画图来找到标签的嵌套关系，多个组件实现小功能，再嵌套组合成复杂的大功能。
首先按照接口字段准备表单对象并进行绑定-按照产品要求准备规则对象并绑定-指定表单域的检验字段名-把表单对象进行双向绑定
#### 自定义校验规则
element+表单组件内置了初始的校验配置，我们可以用它配置一些简单的校验，如果我们想定制特殊的校验需求，可以使用自定义校验规则
```javascript
{
  validator: (rule, val, callback)=>{
    //自定义校验逻辑
    //value: 当前输入的数据
    //callback: 校验处理函数 校验调用
  }
}
```
保证满足条件就调用callback，不满足条件也调用callback，但是传入一个new Error即可（如用if-else等）
#### 验证整个表单内容
用户可能在我们表单为空的时候进行登陆操作，这样表单自己的检验是不生效的，所以我们可以在点击登陆的时候对需要检验的表单属性进行统一检验。element+有validate函数，可以对整个表单域进行校验
#### 登陆的基础业务逻辑
检验表单并通过-封装登录接口-调用登录接口-登录成功进行后续的逻辑处理（如提示用户登录完毕并跳转）-登陆失败（抛出错误提示）
#### Pinia管理用户数据
用户数据可能在很多组件中都用得到，比如获取元素、获取推荐等，所以用集中式管理。我们要把数据相关的所有操作都放到pinia中（state+action），组件只用来触发action函数
#### Pinia数据持久化
用户数据里有一个关键的数据叫Token，可以标识当前用户是否在登录，而Token持续一段时间才会过期。而且Pinia的存储是基于内存的，刷新就会丢失，为了保持我们的登陆状态（刷新不丢失），我们可以配合持久化缓存。我们需要实现操作state时把用户数据在本地的localStorage也存储一份，这样刷新的时候会从localStorage读取。这个功能可以手写也可以使用pinia-plugin-persistedstate插件
#### 登录和非登录状态适配
登录状态下和非登录状态下某些模板展示的内容是不一样的。用v-if决定展示哪种内容即可，有几个需要适配的模板就准备几个template
#### 请求拦截器携带Token
Token作为用户表示， 在很多个接口里面都需要用到才能正确获取数据，比如用户的购物车、用户的推荐信息等，所以需要在接口调用时携带Token。另外，为了统一控制我们采取请求拦截器携带的方案（不需要每个接口都带Token）
Axios请求拦截器可以在接口正式发起之前对请求参数做调整，通常这时候把Token数据注入到请求header中，格式按照后端要求的形式做拼接处理
`config.headers.Authorization = `Bearer ${token}``传入参数是固定格式
#### 退出登录
退出登录有一个删除数据的操作，所以是相对危险的（防止用户误触），所以可以添加一个进行确认的二次弹窗。点击退出弹出确认框-点击确认进行退出逻辑-清除当前用户数据-跳转到登陆页面
#### Token失效401拦截处理
Token是有时效性的，如果用户一段时间不进行任何操作，Token就会失效，而使用失效的Token去请求一些接口，接口就会报401错误，我们就需要进行额外的处理。我们要处理用户在访问哪个接口的时候出现的401错误，以及在什么位置拦截这个错误，还有要如何对401处理。我们需要对每个可能的接口都去进行拦截，所以可以进行响应拦截。思路就是拦截401-清除过期的用户信息-跳转到登录页
## 购物车模块
#### 整体配置
购物车涉及到添加、删除、选择等操作，而进行这些操作的时候我们都要验证Token，如果没有登陆。如果没有登陆，则我们进行的所有操作都是对Pinia中的本地购物车进行操作，不走接口；如果已经登录，则操作是调用接口，操作完毕再次获取购物车列表并更新。购物车也会在多个组件进行调用，所以也要采用Pinia并且进行持久化缓存
#### 加入本地购物车
首先封装一个cartStore（state+action）来作为购物车Store-添加的组件-未选择规格则进行错误提示-已选择规格则根据规格调用action并添加相应的数据到购物车-添加过则增加其技术-没有添加过则直接push。通过匹配传递过来的商品对象中的skuId能不能再cartList中找到，找到就是有，没找到就要push
#### 头部购物车列表渲染
准备头部购物车组件-从pinia中获取数据-渲染列表
#### 头部购物车删除
写删除的action函数-组件中调用action，参数是skuId
#### 头部购物车统计
computed专门用来计算，商品总数是所有商品的count累计，商品总价是所有商品的count*price累计
#### 列表购物车列表渲染
模板-路由-渲染
#### 列表购物车单选
单选的核心思路就是始终把单选框的状态和Pinia中的store对应的状态保持同步。但是，这种情况的双向绑定不应该用v-model，v-model不适合用命令式的操作，它更适用于直接把用户的数据收集或者做显示，而单选功能还需要调用接口来做一些其他操作，所以我们可以用`:model-value`和`@change`一起实现。`:model-value`获取pinia中单选框状态，然后`@change`写一个函数，在单选框状态发生变化的时候传给pinia数据]
#### 列表购物车全选
核心思路：当cartList中的所有内容的selected都为true时，全选状态才为true；cartList的所有selected都要跟着全选状态变。所以还是可以`:model-value`和`@change`分开实现
#### 列表购物车统计
统计数据应该是按照选中的物品来计算，所以找已经selected的商品计算count和price
#### 加入云端购物车
首先用之前本地购物车的action函数-如果不是登录状态继续执行本地购物车逻辑-如果是登陆状态（Token判断）就调用加入云端购物车接口-获取云端购物车列表-用云端购物车列表覆盖本地购物车
#### 删除购物车
和加入购物车一个逻辑，判断是否登录-调用删除购物车接口-调用接口获取购物车-覆盖
#### 退出时删除购物车列表
在购物车store中写一个action，用来清除购物车-在userStore中的退出action里面执行清除购物车业务
#### 合并本地购物车到服务器
用户在非登录时进行的所有购物车操作，在用户登陆后可以把它们与服务端购物车进行合并。核心思路：登陆时调用合并购物车接口-获取最新的购物车列表-覆盖本地的购物车列表
## 结算模块
#### 基础配置
路由配置：准备路由组件-配置路由关系-配置路由跳转
基础数据渲染：准备接口-获取列表数据-渲染地址以及商品列表和统计数据
注意渲染的时候不要写错变量名，要按照接口文档来
#### 地址切换交互
一个部分是打开弹窗的交互，打开弹窗并显示用户的地址列表；第二部分是切换地址的交互，点击弹窗内的地址并确定，激活的地址替换掉默认收货地址
地址切换是tab切换类需求，这种需求实现起来逻辑都是相似的：点击时记录当前的激活地址对象activeAddress，点击哪个地址就记录哪个地址对象；然后通过动态类名`:class`控制css激活样式的active是否存在（激活地址对象的id===当前项id）
#### 结算和生成订单
第一件事是调用接口生成订单id，并且把id交给支付页面，然后调用购物车列表接口，更新购物车
## 支付模块
#### 渲染基础数据
支付页面有两种关键数据，一种是要支付的金额，一种是倒计时数据（超时不支付自动取消订单）。只需要封装订单信息的接口，然后获取关键数据并渲染即可
#### 实现支付功能
支付流程与客户端（前端），服务端（后端）和第三方（支付宝、微信等）有关，![image.png](https://cdn.nlark.com/yuque/0/2024/png/40611437/1724419522983-d15de453-e070-4a4b-bce7-800c50ddfe3e.png#averageHue=%23fc984e&clientId=ue0089847-7115-4&from=paste&height=644&id=u6791224f&originHeight=644&originWidth=1703&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=192826&status=done&style=none&taskId=u70446da9-ddb3-496a-9842-cd2965596b6&title=&width=1703)
在前端需要实现：要支付时跳转支付地址（GET，要订单id和回跳地址），和支付完跳转到回跳地址（订单id+支付状态）
#### 支付结果展示
实现回跳页面，展示支付结果：配置paycallback路由-根据支付结果适配订单状态和支付状态-获取订单数据渲染支付信息
#### 封装倒计时函数
写一个函数useCountDown把秒数格式化为倒计时的显示状态，确定参数和返回值-编写核心倒计时逻辑-实现格式化。定时器及时做清除，否则有可能组件销毁后计时器还在
## 会员中心
#### 整体配置
会员中心分为两部分，一个是个人中心，展示个人信息和猜你喜欢模块的数据渲染；和我的订单，展示各种状态下的订单列表
准备账户页面，个人中心和我的订单组件-绑定账户页面的二级路由-绑定我的订单和个人中心三级路由
#### 个人中心渲染
有用户信息、头像、猜你喜欢等区域需要渲染，信息头像等可以直接用pinia里的账户信息渲染，而猜你喜欢需要用接口调用
#### 我的订单渲染
首先是订单基础列表渲染，封装好订单接口-准备基础请求参数-调用接口请求数据
在订单栏中也有不同种类的订单，如待付款、待发货、已完成等，所以我们可以实现tab切换，获取激活orderState的标签数据，并再次发起请求获取订单数据。绑定tab-change事件-获取当前激活tab项数据-使用最新tab项数据发送请求
订单分页功能：使用数据列表生成分页（页数=总订单数/每页数据数量），用一个total属性绑定总条数，然后使用page-size属性绑定每页的数据数量，切换分页修改page，直接获取订单数据列表。切换分页需要绑定current-change事件-拿到当前页面-使用最新页数发送请求
#### 细节优化
输入二级路由应该自动导入到三级路由内容，不应该显示空白，只需要把三级路由path置空，并在对应的入口组件内把使用到的三级路由改成二级路由的路径
订单状态适配：根据接口文档给出的状态码和中文的对应关系进行适配。可以写对应状态码的函数，然后在模板中渲染出来
## SKU组件
SKU组件的作用是为了让用户能够选择商品的规格，从而提交购物车，在选择的过程中，组件的选中状态要进行更新，组件还要提示用户当前规格是否禁用，每次选择都要产出对应的Sku数据。核心思路有：初始化规格渲染-点击规格更新选中状态-根据规格更新禁用状态-产出选择的SKU数据
#### 点击规格更新选中状态
如果选择项已经激活就取消激活，如果选择项未激活，就把当前的其他规格取消激活，再把选中项激活。可以用响应式selected来决定是否激活，再配合动态class来展示是否激活
#### 点击规格更新禁用状态
生成有效路径字典：规格禁用的判断依据是库存，所以我们应该通过和后端的匹配关系来判断是否具有库存，并对相应的规格组合进行判断是否禁用。当前规格的Sku或组合起来的Sku，在skus数组中对应项的库存为0时会被禁用，生成路径字典可以协助和简化这个匹配过程。实现要根据库存字段得到有效的Sku数组-根据有效的Sku数组使用powerSet算法得到所有子集-根据子集生成路径字典对象
初始化规格禁用：遍历每个规格对象，使用name字段作为key去路径字典pathMap做匹配，匹配不上则禁用。为了做到显示上的禁用，我们可以添加disabled字段，如果匹配上路径字段则disabled为false，也就是不禁用；如果匹配不上路径字段就禁用。然后可以通过动态类名控制样式
点击时组合禁用更新：点击规格时按照顺序得到规格选中项的数组，然后遍历每一种规格，把name字段的值填充到对应的位置，过滤掉undefined项并使用join方法形成一个有效的key，之后使用key在pathMap进行匹配，如果匹配不上则当前项禁用。组合禁用拼接字符串的时候要和生成字典路径的时候使用的拼接字符串的字符相同
#### 产出有效SKU信息
SKU组件的最终目的还是把选择好的信息产出并交给购物车，有效的SKU需要规格全部选择有效，如果用户选择的规格在有效字典路径中找不到undefined，就说明用户已经选择了有效的规格，就可以产出数据。我们想获得SKU信息对象可以用已选择项数组拼接为路径字典的key，然后去路径字典pathMap找即可
